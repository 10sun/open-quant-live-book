```{r include=FALSE}
library(PerformanceAnalytics)
library(riskParityPortfolio)
library(IDPmisc)
library(fPortfolio)
library(xts)
library(purrr)
library(rlist)
```
# Risk Parity Portfolios

## Introduction

## Risk Parity Portfolio

A risk parity portfolio denotes a class of portfolios whose assets verify the following equalities:
\begin{equation}
w_{i} \frac{\partial f(\mathbf{w})}{\partial w_{i}}=w_{j} \frac{\partial f(\mathbf{w})}{\partial w_{j}}, \forall i, j
\end{equation}
where $f$ is a positively homogeneous function of degree one that measures the total risk of the portfolio and $\mathbf{w}$ is the portfolio weight vector. In other words, the marginal risk contributions for every asset in a risk parity portfolio are equal. A common choice for $f$, for instance, is the standard deviation of the portfolio, which is usually called volatility, i.e., $f(\mathbf{w})=\sqrt{\mathbf{w}^{T} \mathbf{\Sigma} \mathbf{w}}$, where $\mathbf{\Sigma}$ is the covariance matrix of assets.

\begin{equation}
w_{i}(\Sigma \mathbf{w})_{i}=b_{i} \mathbf{w}^{T} \Sigma \mathbf{w}, \forall i,
\end{equation}
where $\mathbf{b} \triangleq\left(b_{1}, b_{2}, \ldots, b_{N}\right)\left(\text { with } \mathbf{1}^{T} \mathbf{b}=1 \text { and } \mathbf{b} \geq \mathbf{0}\right)$ is the vector of desired marginal risk contributions.

## Tangency Portfolio

When you analyze a set of assets using mean-variance analysis, the tangency portfolio is the portfolio with the highest Sharpe ratio. It’s called the tangency because it’s located at the tangency point of the Capital Allocation Line and the Efficient Frontier. 

## Optimizing FAANG: Ray Dalio versus Markowitz

### Single Portfolio

First, we will load log-returns of adjusted prices for FAANG companies, i.e., the stocks identified by the following tickers: FB, AMZN, AAPL, NFLX and GOOG (see Appendix \@ref(dt-FAANG) for code used to generate this dataset).
```{r eval=TRUE, echo=TRUE, cache=TRUE}
library(xts)
# load FAANG returns
faang.returns<-as.xts(read.zoo('./data/FAANG.csv',
                               header=TRUE,
                               index.column=1, sep=","))
```

We can use the packages **riskParityPortfolio** and **fPortfolio** to build a FAANG risk parity and tangency portfolios, respectively. We will first consider FAANG returns from 2018 to build the portfolios as follows: 
```{r eval=TRUE, echo=TRUE, cache=TRUE}
library(IDPmisc)
library(riskParityPortfolio)
library(fPortfolio)

# consider returns from 2018
# omit days with missing data (INF/NA returns)
faang.returns.filtered <- NaRV.omit(as.matrix(faang.returns["2018"]))

# calculate covariance matrix
Sigma <- cov(faang.returns.filtered)

# compute risk parity portfolio
portfolio.parity <- riskParityPortfolio(Sigma)

# compute tangency portfolio
portfolio.tangency <- tangencyPortfolio(as.timeSeries(faang.returns.filtered), 
                                        constraints = "LongOnly")
portfolio.weights <- rbind(portfolio.parity$w, getWeights(portfolio.tangency))
row.names(portfolio.weights)<-c("Parity Portfolio", "Tangency Portfolio")
```

Fig. \@ref(fig:parityweights) shows the portfolio weights obtained for both the Parity and the Tangency portfolios. We observe that the Tangency portfolio concentrates the weights between Amazon and Netflix with both companies having nearly the same weight while Facebook, Apple and Google are left out of the portfolio. On the other hand, the Parity portfolio presents a well-balanced distribution of weights among the FAANG companies with all company weights around 20%. Apple and Google have weights a little over 20% while Netflix is the company with the lowest weight (15%).
```{r parityweights, eval=TRUE, echo=TRUE, cache=TRUE,fig.cap="Portfolio weights for parity and tangency FAANG portfolios considering returns from 2018."}
barplot(portfolio.weights, main = "", xlab = "stocks", ylab = "dollars",
        beside = TRUE, legend = TRUE, col=c("black", "red"),
        args.legend = list(bg = "white"))
```

Fig. \@ref(fig:parityrisks) compares the (covariance) risk budget of the Parity and Tangency portfolios obtained. As expected, we observe that the Parity portfolio has a risk budget equally distributed among the portfolio assets. On the other hand, the Tangency portfolio concentrates the risk between Amazon and Netflix with the latter corresponding to over 56% of the risk budget of the portfolio. 


```{r parityrisks, eval=TRUE, echo=TRUE, cache=TRUE, fig.cap="Portfolio covariance risk budget for parity and tangency FAANG portfolios considering returns from 2018."}
portfolio.risks <- rbind(portfolio.parity$risk_contribution/sum(portfolio.parity$risk_contribution), getCovRiskBudgets(portfolio.tangency))
row.names(portfolio.risks)<-c("Parity Portfolio", "Tangency Portfolio")
barplot(portfolio.risks, main = "", xlab = "stocks", ylab = "Covariance Risk Budget",
        beside = TRUE, legend = TRUE, col=c("black", "red"),
        args.legend = list(bg = "white"))
```

### The Ray Dalio FAANG Index

What would be the performance of a "Ray Dalio FAANG Index" i.e. a portfolio composed of FAANG companies and rebalanced to match a corresponding Risk Parity portfolio?  Would it beat a corresponding Tagency portfolio?

To answer these questions, we will consider a portfolio of FAANG companies in the time period from 2014-01-01 and 2019-09-01 and build two indices: 

1. Risk Parity Index: Rebalances portfolio weights quarterly setting the weights according to a risk parity portfolio;
2. Tangency Portfolio Index: Rebalances portfolio weights quarterly setting weights according to a Tangency portfolio.

We first define our rebalance dates by constructing a rolling window of 12-month width and a 3-month step-size as follows: 
```{r eval=TRUE, echo=TRUE, cache=TRUE}
library(fPortfolio)
faang.returns.xts<-faang.returns["2014-01-01/2019-09-01"]
rWindows<-rollingWindows(faang.returns.xts, period="12m",
                         by="3m")
```
Our rebalance dates are the following:
```{r eval=TRUE, echo=TRUE, cache=TRUE}
print(rWindows$to)
```

Next, we calculate risk parity portfolio weights at each rebalance date considering returns in a 12-month window as follows:
```{r eval=TRUE, echo=TRUE, cache=TRUE}
# Apply FUN to time-series R in the subset [from, to].
ApplyFilter <- function(from, to, R, FUN){
  return(FUN(R[paste0(from, "/", to)]))
}
# For each pair (from, to) ApplyFilter to time-series R using FUN
ApplyRolling <- function(from, to, R, FUN){
  library(purrr)
  return(map2(from, to, ApplyFilter, R=R, FUN=FUN))
}
# Returns weights of a risk parity portfolio from covariance matrix of matrix of returns r
CalculateRiskParity <- function(r){
  library(riskParityPortfolio)
  return(riskParityPortfolio(cov(r))$w)
}
# Given a matrix of returns `r`,
# calculates risk parity weights for each date in `to` considering a time window from `from` and `to` 
RollingRiskParity <- function(from, to, r){
  library(rlist)
  p<-ApplyRolling(from, to, r, CalculateRiskParity)
  names(p)<-to
  return(list.rbind(p))
}

parity.weights<-RollingRiskParity(rWindows$from@Data, rWindows$to@Data, faang.returns.xts)
```


We now calculate quarterly weights for FAANG tangency portfolios. We leverage the **fPortfolio** package to calculate a rolling tangency portfolio as follows:
```{r eval=TRUE, echo=TRUE, cache=TRUE, warning = FALSE}
library(fPortfolio)
faang.returns.ts<-as.timeSeries(faang.returns.xts)
Spec = portfolioSpec()

rolling.portfolio.tangency <- rollingTangencyPortfolio(faang.returns.ts,
                                                       constraints = "LongOnly",
                                                       from=rWindows$from,
                                                       to=rWindows$to,
                                                       spec=Spec)

names(rolling.portfolio.tangency)<-rWindows$to
tan.weights <- sapply(rolling.portfolio.tangency,getWeights)
rownames(tan.weights) <- colnames(faang.returns.ts)
tan.weights<-t(tan.weights)
```


Figs. \@ref(fig:rollingparityweights) and \@ref(fig:rollingtangencyweights) show the portfolio weights obtained for parity risk and tangency portfolios, respectively. We observe that the risk parity weights are quite stable over time with Netflix having a slightly underweighting compared to the other portfolio constituents. On the other hand, the tangency portfolio weights vary considerably throughout the time period considered. The tangency portfolio overweights Apple and Amazon across many rebalance dates and it underweights Google in all rebalance dates.  From the portfolios weights alone, we can already conclude that the risk parity index can have considerably lower transaction costs to maintain as its turnover can be quite lower than the one the tangency portfolio strategy.
```{r rollingparityweights, eval=TRUE, echo=TRUE, cache=TRUE, fig.align = "center", fig.cap="Portfolio weights for FAANG risk parity portfolios."}
PerformanceAnalytics::chart.StackedBar(parity.weights, 
                 xlab = "Rebalance Dates",
                 ylab = "Weight", 
                 main = "")
```
```{r rollingtangencyweights, eval=TRUE, echo=TRUE, cache=TRUE, fig.align = "center", fig.cap="Portfolio weights for FAANG tangency portfolios."}
PerformanceAnalytics::chart.StackedBar(tan.weights, xlab = "Rebalance Dates",
                 ylab = "Weight", 
                 main = "")
```

We will use the time series of FAANG companies and the time series of risk parity and tangency portfolio weights to calculate the returns of the risk parity and tangency portfolio indexes as follows:
```{r eval=TRUE, echo=TRUE, cache=TRUE}
library(PerformanceAnalytics)
tan.returns <- Return.portfolio(faang.returns.xts, weights=tan.weights,verbose=TRUE)
parity.returns <- Return.portfolio(faang.returns.xts, weights=parity.weights,verbose=TRUE)
p.returns<-merge(tan.returns$returns, parity.returns$returns)
names(p.returns)<-c("FAANG Tangency Index", "FAANG Parity Index")
```

Fig. \@ref(fig:perfsummary) shows the performance summary for the risk parity index versus the tangency portfolio index.
Surprinsingly, the FAANG risk parity index outperforms the FAANG tangency portfolio index by quite a bit with a cumulative return of `r Return.cumulative(p.returns[,"FAANG Parity Index"])[1]*100`% versus `r Return.cumulative(p.returns[,"FAANG Tangency Index"])[1]*100`% from the tangency portfolio index. The FAANG risk parity index also has a relatively lower drawdown across most of the period analyzed. 
```{r perfsummary, eval=TRUE, echo=TRUE, cache=TRUE, out.width='100%', fig.cap="Performance summary for the risk parity index versus the tangency portfolio index"}
### Performance Summary (return / drawdown)
PerformanceAnalytics::charts.PerformanceSummary(p.returns, colorset=rich6equal,
                          lwd=2, cex.legend = 1.5, event.labels = TRUE, main = "")
```
Tables \@ref(tab:calretparity) and \@ref(tab:calrettangency) show the calendar returns for the risk parity and tangency portfolio indexes, respectively. Interestengly, in years where the tangency portfolio index had positive cumulative return, the risk parity index yielded less returns than the tangency portfolio index. Conversely, in years where the tangency portfolio index had negative cumulative return, the risk parity index showed superior performance than the tangency portfolio index. In that way, the risk parity index showed "not as good" but also "not as bad" yearly returns compared to the tangency portfolios. 

```{r calretparity, eval=TRUE, echo=FALSE, cache=TRUE}
knitr::kable(
t(table.CalendarReturns(p.returns[,"FAANG Parity Index"])),booktabs = TRUE, caption = "Calendar Returns (%): FAANG Parity Index"
)
```
```{r calrettangency, eval=TRUE, echo=FALSE, cache=TRUE}
knitr::kable(
t(table.CalendarReturns(p.returns[,"FAANG Tangency Index"])),booktabs = TRUE, caption = "Calendar Returns (%): FAANG Tangency Index"
)
```

Fig. \@ref(fig:rollingperfsummary) shows the performance summary in a rolling 252-day window. Again, we observe that the risk parity index presents a superior performance compared to the tangency portfolio index. The risk parity index presents higher annualized return, lower standard deviation and superior Sharpe ratio in most of the period analyzed compared to the tangency portfolio index. 
```{r eval=TRUE, echo=FALSE, cache=TRUE}
tab.annual.ret<-table.AnnualizedReturns(p.returns)
```

As presented in Tab. \@ref(tab:annualret), the risk parity index has a total of `r tab.annual.ret["Annualized Return","FAANG Parity Index"]*100`% annualized return, `r tab.annual.ret["Annualized Std Dev","FAANG Parity Index"]*100`% standard deviation and `r tab.annual.ret["Annualized Sharpe (Rf=0%)","FAANG Parity Index"]` Sharpe-ratio versus `r tab.annual.ret["Annualized Return","FAANG Tangency Index"]*100`% annualized return, `r tab.annual.ret["Annualized Std Dev","FAANG Tangency Index"]*100`% standard deviation and `r tab.annual.ret["Annualized Sharpe (Rf=0%)","FAANG Tangency Index"]` Sharpe-ratio from the tangency portfolio index. 

```{r rollingperfsummary, eval=TRUE, echo=FALSE, cache=TRUE, out.width='100%', fig.cap="Performance summary in a rolling 252-day window for the risk parity index versus the tangency portfolio index"}
PerformanceAnalytics::charts.RollingPerformance(p.returns, width = 252, colorset=rich6equal, event.labels = TRUE, legend.loc = "topleft", main = "")
```

```{r annualret, eval=TRUE, echo=FALSE, cache=TRUE}
knitr::kable(
tab.annual.ret,booktabs = TRUE, caption = "Annualized Returns"
)
```

## Discussion and Conclusion




